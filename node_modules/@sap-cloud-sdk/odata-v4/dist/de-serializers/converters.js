"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeToTime = exports.deserializeToTime = exports.serializeToDuration = exports.deserializeDurationToMoment = exports.serializeToDateTimeOffset = exports.deserializeDateTimeOffsetToMoment = exports.serializeToDate = exports.deserializeDateToMoment = void 0;
const internal_1 = require("@sap-cloud-sdk/odata-common/internal");
const moment_1 = __importDefault(require("moment"));
/**
 * @internal
 */
function deserializeDateToMoment(date) {
    const parsed = moment_1.default.utc(date, 'YYYY-MM-DD', true);
    if (!parsed.isValid()) {
        throw new Error(`Provided date value ${date} does not follow the Edm.Date pattern: YYYY-MM-DD`);
    }
    return parsed;
}
exports.deserializeDateToMoment = deserializeDateToMoment;
/**
 * @internal
 */
function serializeToDate(value) {
    return value.format('YYYY-MM-DD');
}
exports.serializeToDate = serializeToDate;
/**
 * @internal
 */
function deserializeDateTimeOffsetToMoment(dateTime) {
    const prefix = 'YYYY-MM-DDTHH:mm';
    // In moment the Z is either Offset from UTC as +-HH:mm, +-HHmm, or Z
    const validFormats = [`${prefix}Z`, `${prefix}:ssZ`, `${prefix}:ss.SSSZ`];
    const parsed = (0, moment_1.default)(dateTime, validFormats, true);
    if (!parsed.isValid()) {
        throw new Error(`Provided date-time value ${dateTime} does not follow the Edm.DateTimeOffset pattern: YYYY-MM-DDTHH:mm(:ss(.SSS))Z`);
    }
    return parsed;
}
exports.deserializeDateTimeOffsetToMoment = deserializeDateTimeOffsetToMoment;
/**
 * @internal
 */
function serializeToDateTimeOffset(value) {
    return value.utc().format('YYYY-MM-DDTHH:mm:ss.SSS') + 'Z';
}
exports.serializeToDateTimeOffset = serializeToDateTimeOffset;
/**
 * @internal
 */
function deserializeDurationToMoment(value) {
    const captured = internal_1.durationRegexV4.exec(value);
    if (!captured || captured[0] !== value) {
        throw new Error(`Provided duration value ${value} does not follow the Edm.Duration pattern: +/- P0DT0H0M0S`);
    }
    return moment_1.default.duration(value);
}
exports.deserializeDurationToMoment = deserializeDurationToMoment;
/**
 * @internal
 */
function serializeToDuration(value) {
    return value.toISOString();
}
exports.serializeToDuration = serializeToDuration;
/**
 * @internal
 */
function deserializeToTime(value) {
    const timeComponents = /(\d{2,2}):(\d{2,2}):(\d{2,2}(\.\d{1,12}){0,1})?/.exec(value);
    if (!timeComponents) {
        throw new Error(`Provided time value ${value} does not follow the Edm.TimeOfDay pattern: HH:MM:SS(.S)`);
    }
    return {
        hours: parseInt(timeComponents[1]),
        minutes: parseInt(timeComponents[2]),
        seconds: parseFloat(timeComponents[3])
    };
}
exports.deserializeToTime = deserializeToTime;
/**
 * @internal
 */
function serializeToTime(value) {
    return [value.hours, value.minutes, value.seconds]
        .map(timeComponent => padTimeComponent(timeComponent))
        .join(':');
}
exports.serializeToTime = serializeToTime;
function padTimeComponent(timeComponent) {
    const [wholeNumber, fractionalNumber] = timeComponent.toString().split('.');
    return fractionalNumber
        ? [wholeNumber.padStart(2, '0'), fractionalNumber].join('.')
        : wholeNumber.padStart(2, '0');
}
//# sourceMappingURL=converters.js.map